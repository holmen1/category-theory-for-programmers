{- Free Category
In mathematics, the free category or path category generated by a directed graph is
the category that results from freely concatenating arrows together, whenever the target
of one arrow is the source of the next.  -}

{- Order

A set with a relation like a <= b and b <= c then a <= c is called a preorder,
so a preorder is indeed a category.
You can also have a stronger relation, that satisfies an additional
condition that, if a <= b and b <= a then a must be the same as b.
That’s called a partial order.

You can also have a stronger relation, that satisfies an additional
condition that, if a <= b and b <= a then a must be the same as b.
That’s called a partial order.
Finally, you can impose the condition that any two objects are in
a relation with each other, one way or another; and that gives you a
linear order or total order.
Let’s characterize these ordered sets as categories. A preorder is a
category where there is at most one morphism going from any object a
to any object b. Another name for such a category is “thin.” A preorder
is a thin category.
A set of morphisms from object a to object b in a category C is called
a hom-set and is written as C(a, b) (or, sometimes, HomC (a, b)). So
every hom-set in a preorder is either empty or a singleton. That includes
the hom-set C(a, a), the set of morphisms from a to a, which must be
a singleton, containing only the identity, in any preorder. You may,
however, have cycles in a preorder. Cycles are forbidden in a partial
order.
It’s very important to be able to recognize preorders, partial or-
ders, and total orders because of sorting. Sorting algorithms, such as
quicksort, bubble sort, merge sort, etc., can only work correctly on to-
tal orders. Partial orders can be sorted using topological sort.-}

{- Monoid as set

Traditionally, a monoid is defined as a set with a binary operation.
All that’s required from this operation is that it’s associative, and that
there is one special element that behaves like a unit with respect to it.

In Haskell we can define a type class for monoids — a type for which
there is a neutral element called mempty and a binary operation called
mappend:-}

class Monoid_ m where
    mempty :: m
    mappend :: m -> m -> m

{- As an example, let’s declare String to be a
monoid by providing the implementation of mempty and mappend: -}
instance Monoid_ String where
    mempty = ""
    mappend = (++)

{- Monoid as Category
A monoid is a single object category.
Every monoid can be described as a single object category with a set
of morphisms that follow appropriate rules of composition.

It turns out that we can always extract a set from a single-object cat-
egory. This set is the set of morphisms — the adders in our example.
In other words, we have the hom-set M(m, m) of the single object m in
the category M.

A lot of interesting phenomena in category theory have their root
in the fact that elements of a hom-set can be seen both as morphisms,
which follow the rules of composition, and as points in a set. Here,
composition of morphisms in M translates into monoidal product in
the set M(m, m).-}